#!/usr/bin/python
'''
Train a network and output it to an XML file.
'''

import sys
import cPickle as pickle
from optparse import OptionParser

import numpy as np
from numpy import matrix, pi, sin, cos
from pybrain.tools.shortcuts import buildNetwork
from pybrain.datasets import SupervisedDataSet
from pybrain.supervised.trainers import BackpropTrainer
from pybrain.tools.xml.networkwriter import NetworkWriter

from leg_defs import s1, s2, s3

ANG1_RANGE = 90
ANG2_RANGE = 180
ANG3_RANGE = 180

X_RANGE = (-10, 15)
Y_RANGE = (-15, 18)
Z_RANGE = (3, 20)

def degToRad(degrees):
    'Convert degrees to radians'
    return degrees * pi / 180.0

def forward(theta1, theta2, theta3):
    '''
    Given the angles of the joints relative to the rest positions
    (s1, s2, and s3), calculate the positions (relative to the
    shoulder) of the two middle joints and the foot.
    '''
    rot1 = rotationMatY3D(-theta1)
    rot2 = rotationMatX3D(theta2)
    rot3 = rotationMatX3D(theta3)
    delta1 = rot1 * s1
    delta2 = delta1 + (rot1 * rot2 * s2)
    delta3 = delta2 + ((rot1 * rot2 * rot3) * s3)
    return delta1, delta2, delta3

def rotationMatX3D(theta):
    return matrix([
        [1, 0, 0],
        [0, cos(theta), -sin(theta)],
        [0, sin(theta), cos(theta)],
    ], dtype=float)

def rotationMatY3D(theta):
    return matrix([
        [cos(theta), 0, sin(theta)],
        [0, 1, 0],
        [-sin(theta), 0, cos(theta)],
    ], dtype=float)

def genRandomSamples(numSamples):
    '''
    Generator that produces a sequence of `numSamples` random training
    samples.  Samples are generated by randomly selecting angles, so the
    distribution is not even across the leg's volume.
    '''
    randAng1 = degToRad(np.random.random_sample(numSamples) * ANG1_RANGE - (ANG1_RANGE / 2.0))
    randAng2 = degToRad(np.random.random_sample(numSamples) * ANG2_RANGE - (ANG2_RANGE / 2.0))
    randAng3 = degToRad(np.random.random_sample(numSamples) * ANG3_RANGE - (ANG3_RANGE / 2.0))
    for a1, a2, a3 in zip(randAng1, randAng2, randAng3):
        j1, j2, j3 = forward(a1, a2, a3)
        yield (np.asarray(j3.getT())[0, :], (a1, a2, a3))

def genConstrainedSamples(numSamples):
    count = 0
    while count < numSamples:
        samples = genRandomSamples(numSamples)
        for input, output in samples:
            if (X_RANGE[0] <= input[0] <= X_RANGE[1] and
                Y_RANGE[0] <= input[1] <= Y_RANGE[1] and
                Z_RANGE[0] <= input[2] <= Z_RANGE[1]):

                yield input, output

                count += 1
                if count >= numSamples:
                    break

def meshLocations(step=1):
    '''
    Yield 3-tuples of each round-number point in the training volume.
    '''
    for x in range(X_RANGE[0], X_RANGE[1] + 1, step):
        for y in range(Y_RANGE[0], Y_RANGE[1] + 1, step):
            for z in range(Z_RANGE[0], Z_RANGE[1] + 1, step):
                yield (x, y, z)

def genEvenSamples(numSamples):
    '''
    Generator that produces a sequence of `numSamples` random training
    samples.  
    '''
    numBins = len(list(meshLocations()))
    samplesPerBin = (numSamples // numBins) + 10
    print 'Placing', samplesPerBin, 'in each of', numBins, 'bins'

    binMap = {}
    for x, y, z in meshLocations():
        binMap[x, y, z] = 0

    sampleCount = 0
    while sampleCount < numSamples:
        for input, output in genRandomSamples(numSamples * 2):
            bin = tuple(map(int, input))
            if binMap.get(bin, samplesPerBin) < samplesPerBin:
                binMap[bin] += 1
                yield (input, output)
                #sys.stdout.write('.')
            #else:
                #sys.stdout.write('!')
                #print bin, input, output
        if sum(binMap.itervalues()) - sampleCount < 50:
            print "Aborting because of slow gains"
            break
        sampleCount = sum(binMap.itervalues())
        print sampleCount
    #import ipdb; ipdb.set_trace()


def genSamples(numSamples, method):
    if method == 'random':
        samples = genRandomSamples(numSamples)
    elif method == 'even':
        samples = genEvenSamples(numSamples)
    elif method == 'constrained':
        samples = genConstrainedSamples(numSamples)
    else:
        raise ValueError('Unknown sample generation method')

    return list(samples)

def samplesToDataset(samples):
    dataset = SupervisedDataSet(3, 3)
    for input, output in samples:
        dataset.addSample(input, output)
    return dataset

def train(ds, numIterations):
    net = buildNetwork(3, 10, 10, 3)
    trainer = BackpropTrainer(net, ds)
    for i in xrange(numIterations):
        error = trainer.train()
        print 'train iter {0:4d} error {1}'.format(i, error)
    return net

if __name__ == '__main__':
    op = OptionParser(usage='%prog [options]')
    op.add_option('-s', '--samples',
                  help='number of samples to train with',
                  type='int')
    op.add_option('-i', '--iterations',
                  help='number of iterations to train the net for',
                  type='int')
    op.add_option('-m', '--sample-method', metavar='METHOD',
                  help='method to use to generate the samples',
                  choices=('random', 'even', 'constrained'))
    op.add_option('', '--load-samples', metavar='FILE.pickle',
                  help='pickle file to load the samples from')
    op.add_option('', '--output-samples', metavar='FILE.pickle',
                  help='pickle file to save the samples to')
    op.add_option('-o', '--output-network', metavar='FILE.xml',
                  help='XML file to save the network to')
    op.set_defaults(
            samples=30000,
            iterations=600,
            sample_method='even',
            load_samples=None,
            output_samples=None,
            output_network=None)
    options, args = op.parse_args()

    samples = None
    if options.load_samples is not None:
        print 'Loading samples from', options.load_samples
        with open(options.load_samples) as f:
            samples = pickle.load(f)
    else:
        print 'Generating', options.samples, 'samples'
        samples = genSamples(options.samples, options.sample_method)
        if options.output_samples is not None:
            print 'Saving samples to', options.output_samples
            with open(options.output_samples, 'w') as f:
                pickle.dump(samples, f)

    if options.output_network:
        print 'Generating dataset of', len(samples), 'samples'
        dataset = samplesToDataset(samples)
        print 'Training network for', options.iterations, 'iterations'
        net = train(dataset, options.iterations)
        print 'Writing network to', options.output_network
        NetworkWriter.writeToFile(net, options.output_network)

